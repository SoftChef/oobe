<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>SpriteUnit.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Collection.html">Collection</a><ul class='methods'><li data-type='method'><a href="Collection.html#batchWrite">batchWrite</a></li><li data-type='method'><a href="Collection.html#batchWriteAsync">batchWriteAsync</a></li><li data-type='method'><a href="Collection.html#batchWriteOnlyKeys">batchWriteOnlyKeys</a></li><li data-type='method'><a href="Collection.html#clear">clear</a></li><li data-type='method'><a href="Collection.html#distAll">distAll</a></li><li data-type='method'><a href="Collection.html#emit">emit</a></li><li data-type='method'><a href="Collection.html#fetch">fetch</a></li><li data-type='method'><a href="Collection.html#forEach">forEach</a></li><li data-type='method'><a href="Collection.html#getBodys">getBodys</a></li><li data-type='method'><a href="Collection.html#getExports">getExports</a></li><li data-type='method'><a href="Collection.html#getOrigins">getOrigins</a></li><li data-type='method'><a href="Collection.html#has">has</a></li><li data-type='method'><a href="Collection.html#isChange">isChange</a></li><li data-type='method'><a href="Collection.html#off">off</a></li><li data-type='method'><a href="Collection.html#on">on</a></li><li data-type='method'><a href="Collection.html#onOnce">onOnce</a></li><li data-type='method'><a href="Collection.html#remove">remove</a></li><li data-type='method'><a href="Collection.html#setDirty">setDirty</a></li><li data-type='method'><a href="Collection.html#toKey">toKey</a></li><li data-type='method'><a href="Collection.html#validate">validate</a></li><li data-type='method'><a href="Collection.html#write">write</a></li></ul></li><li><a href="Helper.html">Helper</a><ul class='methods'><li data-type='method'><a href="Helper.html#.deepObjectAssign">deepObjectAssign</a></li><li data-type='method'><a href="Helper.html#.generateId">generateId</a></li><li data-type='method'><a href="Helper.html#.getType">getType</a></li><li data-type='method'><a href="Helper.html#.isCollection">isCollection</a></li><li data-type='method'><a href="Helper.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="Helper.html#.isSprite">isSprite</a></li><li data-type='method'><a href="Helper.html#.jpjs">jpjs</a></li><li data-type='method'><a href="Helper.html#.peel">peel</a></li><li data-type='method'><a href="Helper.html#.verify">verify</a></li></ul></li><li><a href="Oobe.html">Oobe</a><ul class='methods'><li data-type='method'><a href="Oobe.html#addon">addon</a></li><li data-type='method'><a href="Oobe.html#batch">batch</a></li><li data-type='method'><a href="Oobe.html#collection">collection</a></li><li data-type='method'><a href="Oobe.html#emit">emit</a></li><li data-type='method'><a href="Oobe.html#getRules">getRules</a></li><li data-type='method'><a href="Oobe.html#instanceof">instanceof</a></li><li data-type='method'><a href="Oobe.html#join">join</a></li><li data-type='method'><a href="Oobe.html#make">make</a></li><li data-type='method'><a href="Oobe.html#meg">meg</a></li><li data-type='method'><a href="Oobe.html#off">off</a></li><li data-type='method'><a href="Oobe.html#on">on</a></li><li data-type='method'><a href="Oobe.html#onOnce">onOnce</a></li><li data-type='method'><a href="Oobe.html#plugin">plugin</a></li><li data-type='method'><a href="Oobe.html#setLocale">setLocale</a></li></ul></li><li><a href="Sprite.html">Sprite</a><ul class='methods'><li data-type='method'><a href="Sprite.html#$bind">$bind</a></li><li data-type='method'><a href="Sprite.html#$body">$body</a></li><li data-type='method'><a href="Sprite.html#$born">$born</a></li><li data-type='method'><a href="Sprite.html#$copy">$copy</a></li><li data-type='method'><a href="Sprite.html#$dead">$dead</a></li><li data-type='method'><a href="Sprite.html#$dist">$dist</a></li><li data-type='method'><a href="Sprite.html#$distortion">$distortion</a></li><li data-type='method'><a href="Sprite.html#$emit">$emit</a></li><li data-type='method'><a href="Sprite.html#$export">$export</a></li><li data-type='method'><a href="Sprite.html#$isChange">$isChange</a></li><li data-type='method'><a href="Sprite.html#$isFixed">$isFixed</a></li><li data-type='method'><a href="Sprite.html#$isHidden">$isHidden</a></li><li data-type='method'><a href="Sprite.html#$keys">$keys</a></li><li data-type='method'><a href="Sprite.html#$meg">$meg</a></li><li data-type='method'><a href="Sprite.html#$off">$off</a></li><li data-type='method'><a href="Sprite.html#$on">$on</a></li><li data-type='method'><a href="Sprite.html#$onOnce">$onOnce</a></li><li data-type='method'><a href="Sprite.html#$out">$out</a></li><li data-type='method'><a href="Sprite.html#$put">$put</a></li><li data-type='method'><a href="Sprite.html#$raw">$raw</a></li><li data-type='method'><a href="Sprite.html#$reset">$reset</a></li><li data-type='method'><a href="Sprite.html#$revive">$revive</a></li><li data-type='method'><a href="Sprite.html#$rules">$rules</a></li><li data-type='method'><a href="Sprite.html#$setError">$setError</a></li><li data-type='method'><a href="Sprite.html#$show">$show</a></li><li data-type='method'><a href="Sprite.html#$toObject">$toObject</a></li><li data-type='method'><a href="Sprite.html#$toOrigin">$toOrigin</a></li><li data-type='method'><a href="Sprite.html#$validate">$validate</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Collection.html#event:$clear">$clear</a></li><li><a href="Collection.html#event:$fetch">$fetch</a></li><li><a href="Collection.html#event:$fetchFail">$fetchFail</a></li><li><a href="Collection.html#event:$writeAsyncDone">$writeAsyncDone</a></li><li><a href="Collection.html#event:$writeReject">$writeReject</a></li><li><a href="Collection.html#event:$writeSuccess">$writeSuccess</a></li><li><a href="Sprite.html#event:$error">$error</a></li><li><a href="Sprite.html#event:$export">$export</a></li><li><a href="Sprite.html#event:$init">$init</a></li><li><a href="Sprite.html#event:$ready">$ready</a></li><li><a href="Sprite.html#event:$reset">$reset</a></li></ul><h3>Namespaces</h3><ul><li><a href="Container.html">Container</a></li><li><a href="SpriteBase.html">SpriteBase</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">SpriteUnit.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Base = require('./Base')
const Event = require('./Event')
const Sprite = require('./Sprite')
const Helper = require('./Helper')

class SpriteUnit extends Base {
    constructor(base) {
        super('Sprite')
        this.body = {}
        this.refs = {}
        this.soul = null
        this.from = null
        this.base = base
        this.dist = base.dists.read
        this.views = null
        this.parent = null
        this.options = base.options
        this.rawBody = ''
        this.rawData = null
        this.functions = null
        this.propertyNames = []
        this.init()
    }

    dataParse(data = null) {
        return JSON.parse(data)
    }

    dataStringify(data) {
        return JSON.stringify(data)
    }

    getBody() {
        let output = Helper.jpjs(this.body)
        this.eachRefs((taget, key, type) => {
            if (type === 'collection') {
                output[key] = taget.getBodys()
            } else {
                output[key] = taget.getBody()
            }
        })
        return output
    }

    getKeys() {
        let refs = Object.keys(this.base.options.refs)
        return this.propertyNames.concat(refs)
    }

    getErrorMessage() {
        return this.base.options.errorMessage(this.status.error)
    }

    getProperty(name) {
        if (this.propertyNames.includes(name)) {
            return this.unit[name]
        } else {
            this.$devError('getProperty', `Property name(${name}) not found.`)
        }
    }

    isLive() {
        if (this.status.live === false) {
            this.$devError('isLive', 'This Sprite is dead.')
            return false
        }
        if (this.isError()) {
            this.$devError('isLive', 'This Sprite is error.')
            return false
        }
        return true
    }

    isReady() {
        return !!this.status.ready
    }

    isError() {
        return !!this.status.error
    }

    isInitialization() {
        return !!this.status.init
    }

    isChange(key) {
        if (key &amp;&amp; this.getProperty(key)) {
            let target = this.unit[key]
            if (Helper.isSprite(target)) {
                return target.isChange()
            } else {
                return target !== this.dataParse(this.rawBody)[key]
            }
        } else {
            let change = this.rawBody !== this.dataStringify(this.body)
            if (change) return true
            this.eachRefs((target) => {
                change = target.isChange()
                if (change) {
                    return '_break'
                }
            })
            return change
        }
    }

    /**
     * Invoke $export() to trigger.
     * @event Sprite#$export
     * @property {object} context
     */

    export(name, args) {
        let dist = null
        if (name) {
            dist = this.base.dists[name]
            if (dist == null) {
                this.$devError('export', `Dist(${name}) not found.`)
            }
        } else {
            dist = this.dist
        }
        let result = dist.options.export.apply(this.unit, args)
        this.event.emit(this.unit, '$export', [{ result, dist: dist.name }])
        return result
    }

    toOrigin() {
        return this.options.origin.call(this.unit)
    }

    out() {
        if (this.isLive()) {
            this.soul = this.copy()
            this.soul.from = this
            this.sleep()
            return this.soul
        }
    }

    sleep() {
        this.status.live = false
        this.eachRefs((target, key, type) => {
            if (type === 'sprite') {
                target.sleep()
            } else {
                target.forEach((sprite) => {
                    sprite.sleep()
                })
            }
        })
    }

    wakeup() {
        this.status.live = true
        this.eachRefs((target, key, type) => {
            if (type === 'sprite') {
                target.wakeup()
            } else {
                target.forEach((sprite) => {
                    sprite.wakeup()
                })
            }
        })
    }

    revive() {
        if (this.isLive()) {
            if (this.from) {
                this.from.reborn(this.toOrigin())
                return this.dead()
            } else {
                this.$devError('revive', 'This Sprite is root.')
            }
        }
    }

    copy() {
        if (this.isReady()) {
            return this.base.create().born(this.toOrigin()).distortion(this.dist.name)
        } else {
            this.$devError('copy', 'Sprite not ready.')
        }
    }

    dead() {
        if (this.isLive()) {
            let from = this.from
            if (this.from) {
                this.from.wakeup()
                this.from.soul = null
                this.from = null
                this.sleep()
                return from
            } else {
                this.$devError('dead', 'This Sprite is root.')
            }
        }
    }

    reborn(origin) {
        this.wakeup()
        this.setBody(origin)
    }

    /**
     * Invoke core.reset() to trigger.
     * @event Sprite#$reset
     * @property {object} context
     */

    reset(key) {
        if (this.isLive()) {
            if (key) {
                if (this.getProperty(key)) {
                    this.unit[key] = this.dataParse(this.rawBody)[key]
                }
            } else {
                this.setBody(this.dataParse(this.rawData))
            }
            this.event.emit(this.unit, '$reset')
        }
    }

    setBody(data) {
        let reborn = this.options.born.call(this.unit, data) || {}
        for (let key of this.propertyNames) {
            this.unit[key] = reborn[key] === undefined ? this.unit[key] : reborn[key]
        }
        this.eachRefs((target, key, type) => {
            if (type === 'sprite') {
                target.isReady() ? target.setBody(reborn[key]) : target.born(reborn[key])
            } else {
                target.clear()
                if (reborn[key]) {
                    target.batchWrite(reborn[key])
                }
            }
        })
        this.unit.$self = this.base.options.self.call(this.unit, data)
    }

    /**
     * Invoke $setError() to trigger.
     * @event Sprite#$error
     * @property {object} context
     * @property {*} errorData
     */

    setError(data) {
        this.status.error = data || 'Unknown error'
        this.event.emit(this.unit, '$error', [data])
    }

    put(data) {
        if (this.isLive()) {
            for (let key of this.propertyNames) {
                if (data[key] !== undefined) {
                    this.unit[key] = data[key]
                }
            }
            this.eachRefs((target, key, type) => {
                if (type === 'sprite') {
                    if (data[key] !== undefined) {
                        target.put(data[key])
                    }
                } else {
                    if (Array.isArray(data[key])) {
                        target.clear()
                        for (let body of data[key]) {
                            target.write(target.generateSprite({}).$put(body))
                        }
                    }
                }
            })
        }
        return this
    }

    eachRefs(callback) {
        for (let key in this.refs) {
            let type = this.refs[key] instanceof SpriteUnit ? 'sprite' : 'collection'
            let result = callback(this.refs[key], key, type)
            if (result === '_break') {
                break
            }
        }
    }

    distortion(name) {
        if (this.isLive()) {
            if (this.base.dists[name] == null) {
                return this.$devError('distortion', `Name(${name}) not found.`)
            }
            this.dist = this.base.dists[name]
            this.eachRefs((target) => {
                target.distortion(name)
            })
            return this
        }
    }

    bind(name) {
        let target = this.functions[name]
        if (target == null) {
            return this.$devError('bind', `Method(${name}) not found`)
        }
        return this.functions[name].bind(this.functions)
    }

    /**
     * Invoke $born() to trigger.
     * @event Sprite#$ready
     * @property {object} context
     */

    born(data) {
        if (this.isReady()) {
            this.$devError('born', 'Sprite is ready.')
        }
        if (this.isLive()) {
            this.setBody(data)
            this.rawBody = this.dataStringify(this.body)
            this.rawData = this.dataStringify(data)
            this.base.options.created.call(this.unit)
            this.status.ready = true
            this.event.emit(this.unit, '$ready')
            return this
        }
    }

    toObject() {
        let object = this.getBody()
        object.$self = {}
        object.$views = {}
        object.$status = Helper.jpjs(this.status)
        for (let key in this.unit.$self) {
            object.$self[key] = this.unit.$self[key]
        }
        for (let key in this.base.options.views) {
            object.$views[key] = this.views[key]
        }
        return object
    }

    /**
     * Invoke core.make() to trigger.
     * @event Sprite#$init
     * @property {object} context
     * @property {Sprite} self
     */

    init() {
        this.initUnit()
        this.initBody()
        this.checkBody()
        this.initEvent()
        this.initStatus()
        this.rawBody = this.dataStringify(this.body)
        this.rawData = null
        this.propertyNames = Object.keys(this.body || {})
        this.status.init = true
        this.event.emit(this.unit, '$init', [this.unit])
    }

    initEvent() {
        this.event = new Event('unit', this.base.event)
    }

    initStatus() {
        this.status = {
            live: true,
            init: false,
            error: null,
            ready: false
        }
    }

    initUnit() {
        this.unit = new Sprite(this)
        this.functions = this.base.getMethods(this.unit)
        if (this.base.options.defaultView &amp;&amp; typeof Proxy !== 'undefined') {
            let defaultView = this.base.options.defaultView
            this.views = new Proxy(this.base.getViews(this.unit), {
                get: (target, key) => {
                    let value = null
                    if (target[key] != null) {
                        value = target[key]
                    }
                    if (value == null) {
                        value = defaultView.call(this.unit, { key })
                    }
                    return value
                }
            })
        } else {
            this.views = this.base.getViews(this.unit)
        }
    }

    initBody() {
        let refs = this.options.refs
        let body = this.options.body.call(this.unit)
        for (let key in body) {
            this.body[key] = body[key]
            Object.defineProperty(this.unit, key, {
                get: this.getDefineProperty('body', key),
                set: this.setDefineProperty(key)
            })
        }
        for (let key in refs) {
            let name = refs[key]
            if (name[0] === '[' &amp;&amp; name.slice(-1) === ']') {
                this.refs[key] = this.base.container.makeCollection(name.slice(1, -1))
            } else {
                this.refs[key] = this.base.container.make(name)
            }
            this.refs[key].parent = this.unit
            Object.defineProperty(this.unit, key, {
                get: this.getDefineProperty('refs', key),
                set: this.setDefineProperty(key, true)
            })
        }
    }

    checkBody() {
        for (let key in this.body) {
            let value = this.body[key]
            let type = Helper.getType(value)
            if (type === 'function') {
                this.$devError('checkBody', `Body ${key} can't be a function.`)
            }
            if (key[0] === '$' || key[0] === '_') {
                this.$devError('checkBody', `Body ${key} has system symbol $ and _.`)
            }
        }
    }

    getRules(name, extra = []) {
        let rules = this.base.options.rules[name]
        if (rules == null) {
            this.$devError('getRules', `Rule name(${name}) not found.`)
        }
        return this.base.container.getRules(this.unit, rules.concat(extra))
    }

    getRawdata(assign) {
        let data = this.dataParse(this.rawData)
        return assign ? Helper.deepObjectAssign(data, assign) : data
    }

    validate(value, name) {
        let rules = this.base.options.rules[name]
        return this.base.container.validate(this.unit, value, rules)
    }

    validateAll() {
        let keys = Object.keys(this.base.options.rules)
        let result = {}
        let success = true
        for (let name of keys) {
            let value = this.unit[name]
            let check = this.validate(value, name)
            if (check !== true) {
                result[name] = check
                success = false
            }
        }
        this.eachRefs((target, key) => {
            result[key] = target.validateAll()
            if (result[key].success === false) {
                success = false
            }
        })
        return { result, success }
    }

    getDefineProperty(name, key) {
        if (name === 'refs') {
            return () => this.refs[key].unit
        } else {
            return () => this.body[key]
        }
    }

    setDefineProperty(key, protect) {
        return (value) => {
            if (this.isLive()) {
                if (protect) {
                    return this.$devError('set', `This property(${key}) is protect.`)
                }
                if (typeof value === 'function') {
                    return this.$devError('set', 'Body data not allow function.')
                }
                this.body[key] = value
            }
        }
    }
}

module.exports = SpriteUnit
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Mon Nov 18 2019 09:29:09 GMT+0800 (GMT+08:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
